<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Roz Dakin">
<meta name="dcterms.date" content="2025-03-02">

<title>BIOL 5404 Assignment 4</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="assignment_4_files/libs/clipboard/clipboard.min.js"></script>
<script src="assignment_4_files/libs/quarto-html/quarto.js"></script>
<script src="assignment_4_files/libs/quarto-html/popper.min.js"></script>
<script src="assignment_4_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="assignment_4_files/libs/quarto-html/anchor.min.js"></script>
<link href="assignment_4_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="assignment_4_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="assignment_4_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="assignment_4_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="assignment_4_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="2">
    <h2 id="toc-title">BIOL 5404 A4</h2>
   
  <ul>
  <li><a href="#instructions" id="toc-instructions" class="nav-link active" data-scroll-target="#instructions">Instructions</a></li>
  <li><a href="#part-1" id="toc-part-1" class="nav-link" data-scroll-target="#part-1">Part 1</a></li>
  <li><a href="#part-2" id="toc-part-2" class="nav-link" data-scroll-target="#part-2">Part 2</a></li>
  <li><a href="#part-3" id="toc-part-3" class="nav-link" data-scroll-target="#part-3">Part 3</a></li>
  <li><a href="#part-4" id="toc-part-4" class="nav-link" data-scroll-target="#part-4">Part 4</a></li>
  <li><a href="#part-5" id="toc-part-5" class="nav-link" data-scroll-target="#part-5">Part 5</a></li>
  <li><a href="#extra-optional-challenges" id="toc-extra-optional-challenges" class="nav-link" data-scroll-target="#extra-optional-challenges">Extra optional challenges</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">BIOL 5404 Assignment 4</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Roz Dakin </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Due on</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 2, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p><a href="index.html#assignments">Back to assignment list</a></p>
<section id="instructions" class="level2">
<h2 class="anchored" data-anchor-id="instructions">Instructions</h2>
<ul>
<li>Create a new .R script to complete this assignment in your local assignments folder for this course.</li>
<li>You’ll submit the .R script on Brightspace.</li>
<li><strong><em>Put your FIRST and LAST NAME in the <u>file name</u> of the script.</em></strong></li>
<li>Put your name at the top of the script as well.</li>
<li>Please do not include your student ID, just your name is enough.</li>
<li><strong>Show your work!</strong></li>
<li>Make sure your script is organized and legible.</li>
<li>Use <a href="https://support.posit.co/hc/en-us/articles/200484568-Code-Folding-and-Sections-in-the-RStudio-IDE">code sections</a> (####) &amp; question numbers as outlined below.</li>
<li>Provide all written answers as brief # comments within your script.</li>
<li>Be sure to load all packages needed at the top of your script, like this (adding any other packages needed):</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gridExtra)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(gapminder)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In this assignment, we will use a few different datasets:</p>
<ul>
<li><p>We will work on graphing data from Roche et al.&nbsp;on completeness and reusability scores for publicly archived data (we’ll remake their Figure 3).</p></li>
<li><p>We will use a dataset on population sizes of ancient cities throughout history, from 3700 BC to 2000 AD, by Modelski. We will need to do some cleaning/quality control, some wrangling, and then we’ll practice visualizing aspects of this dataset.</p></li>
<li><p>In the optional challenge at the end, we will use the gapminder dataset from the <code>gapminder</code> package to integrate continent names with Modelski’s city data (you will need to install the gapminder package to do this optional section, if you don’t have it already).</p></li>
</ul>
</section>
<section id="part-1" class="level2">
<h2 class="anchored" data-anchor-id="part-1">Part 1</h2>
<p>Let’s start by plotting the data from Roche et al.’s study of data archiving. First, read in the data from the csv file <strong>Dryad_data_2012_2013.csv</strong></p>
<p>1a. Use ggplot to re-create (as closely as you can!) their scatterplot from <strong>Figure 3</strong> below showing the relationship between reusability score (y-axis) and completeness score (x-axis). Your graph should copy the features of Figure 3 as much as possible. Note, their graph uses <code>position = position_jitter()</code>, and you should too, but you won’t be able to replicate the exact positioning of the randomly jittered points.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="Figure_3_option_1.jpeg" class="img-fluid quarto-figure quarto-figure-left figure-img" width="370"></p>
</figure>
</div>
<p>1b. Now, use ggplot to re-draw their <strong>Figure 3</strong> as a <em>different</em> type of graph where there is only one dot/point per score combination, and where the AREA size of each dot represents the number of papers with that combination of scores. See the example below to see what I mean. In your plot, include a legend so readers can interpret the area sizes.</p>
<p>Hint: <code>geom_count()</code> is a shortcut to do this. You can also do this if you <code>group_by()</code> complScore AND reuseScore, then make a new dataframe that counts up the occurrence of each unique score combination, then use that new df for your graph.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="Figure_3_option_2.jpeg" class="img-fluid quarto-figure quarto-figure-left figure-img" width="545"></p>
</figure>
</div>
<p>1c. Now, use ggplot to re-draw their <strong>Figure 3</strong> as a <strong>heatmap</strong>, where the colour of each cell represents the number of papers with that combination of scores. Use a scale of two colours (e.g, yellow –&gt; red, or choose your own color scale) to represent values from 1 to the max number of papers per cell. See the example below to see what I mean.</p>
<p>Hint: as above, a good way to do this is group_by complScore and reuseScore, then make a new df that counts up the occurrence of each unique score combination. Then, take that df of counts and use that to draw your heatmap.</p>
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="Figure_3_option_3.jpeg" class="img-fluid quarto-figure quarto-figure-left figure-img" width="560"></p>
</figure>
</div>
<p>1d. Finally, use <code>grid.arrange()</code> from the <code>gridExtra</code> package to make a layout that shows ALL three of your candidate plots on a single “page”. Which do you prefer?</p>
<p><strong>OPTIONAL:</strong> Use grey to fill in the cells of your heatmap that have 0 papers represented. Remove the extra “padding” around the coloured cells so that the border of the plot just includes the coloured areas. See my example above to see what I mean.</p>
</section>
<section id="part-2" class="level2">
<h2 class="anchored" data-anchor-id="part-2">Part 2</h2>
<p>Now, let’s take a look at Modelski’s data on ancient cities throughout history. There are two csv files on Brightspace, <strong>modelskiAncientV2.csv</strong> and <strong>modelskiModernV2.csv</strong>. Download them and read them into the R environment.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://commons.wikimedia.org/wiki/File:Teotihuacan_(cropped).jpg"><img src="1024px-Teotihuacan_(cropped).jpg" class="img-fluid figure-img" alt="The ancient city of Teotihuacan in Mexico (Wikimedia Commons)."></a></p>
<figcaption>The ancient city of Teotihuacan in Mexico (Wikimedia Commons).</figcaption>
</figure>
</div>
<p>Background: one of the first steps when cleaning up a new dataset (data hygiene) is to sit down and think through the logic of what you expect in the data. For example, what are potential IMPOSSIBLE values for each column (or group of columns)? How many duplicates of a given value, or combination of values across two or more columns, do you expect? What kind of issues could occur as a result of typos in a dataset, and how would you sleuth out those issues?</p>
<p>A general workflow is to first WRITE DOWN all of the reality checks you can possible think of, and then, CHECK them one by one.</p>
<p>2a. Inspect the two Modelski dataframes in R, and briefly describe what the two datasets contain. Is each dataset in long or wide format? Is each dataset tidy? If not, what would you need to do to make it tidy?</p>
<p>** Note that you will want to use tidyverse’s <code>read_csv()</code> function, because there are some odd characters that <code>read.csv()</code> stumbles on.</p>
<p>2b. Write down a list of things you would check in the <strong>ANCIENT</strong> dataset focusing on these items:</p>
<ol type="i">
<li><code>City</code>,</li>
<li><code>Latitude</code> (note: we’ll solve issues in this column in 2c),</li>
<li><code>Longitude</code>,</li>
<li>the population sizes (i.e., values in columns 7:47), and</li>
<li>the year info (stored in those column names).</li>
</ol>
<p>2c. Now, <strong>investigate</strong> (look at) the items on your list above in 2b.</p>
<p>Note: I’m asking you to use your tidyverse skills to investigate each of your checks from 2b, and in each case, describe what you see. You don’t have to fix anything for 2c. Just demonstrate a thorough investigation.</p>
<p>2d. There are two errors in the <code>latitude</code> column of the <strong>ANCIENT</strong> dataset. Fix the two errors in <code>latitude</code> before proceeding to Part 3. You could either find the two errors and fix each one using indexing, as shown here:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>data<span class="sc">$</span>latitude[index] <span class="ot">&lt;-</span> <span class="st">"the.corrected.value"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>…OR you could investigate how to use <code>str_replace_all()</code> to do this.</p>
<p>After fixing the two errors, convert the <code>latitude</code> column to <code>as.numeric()</code>.</p>
<p><strong>OPTIONAL:</strong> In addition to the latitude errors in the <strong>ANCIENT</strong> dataset, I DID find at least one typo in the <strong>Modern</strong> dataset. Can you find it? AND there is also an aspect of the <strong>Modern</strong> dataset that poses a potential issue, but upon investigation, it is not actually a mistake. Can you find that one, too?</p>
</section>
<section id="part-3" class="level2">
<h2 class="anchored" data-anchor-id="part-3">Part 3</h2>
<p>Our next goal is to generate a single long-format dataset that combines BOTH the Ancient and the Modern city population sizes. We want our long dataset to have these 6 columns:</p>
<ul>
<li>City,</li>
<li>Country,</li>
<li>Latitude,</li>
<li>Longitude,</li>
<li>year,</li>
<li>and population.</li>
</ul>
<p>To get there, we’ll have to do some reshaping/tidying first.</p>
<p>3a. Using pipes &amp; tidyverse functions, do the following steps to reshape/tidy the <strong>Ancient</strong> data:</p>
<ol type="i">
<li><p>Pivot the Ancient data to long format with new columns that contain <code>year</code> and <code>population</code>.</p></li>
<li><p>Then, take the year information (such as BC_3700 or AD_1000) and create a numerical column with just the <code>numerical_year</code>.</p></li>
<li><p>Make <code>numerical_year</code> a negative number if the year is BC, but leave it as-is (positive) if the year is AD. You should end up with years that range from -3700 to 1000.</p>
<p>Hint: it may help to make a column with character info as to whether a given year is BC vs.&nbsp;AD.</p></li>
<li><p>Use <code>select()</code> to pare down your dataframe to just 6 desired columns: <code>City</code>, <code>Country</code>, <code>Latitude</code>, <code>Longitude</code>, <code>numerical_year</code>, and <code>population</code></p></li>
<li><p>Assign this new long dataframe a name, so that it’s available for further work.</p></li>
</ol>
<p>3b. Using pipes &amp; tidyverse functions, tidy up the <strong>Modern</strong> data so that it has the EXACT same 6 column names (variables) as the dataset your just prepared above. Working with the Modern data, you will want to create a new <code>numerical_year</code> column with the correct values (all year 2000), name the population column appropriately, and then use <code>select()</code> to pare down to just the 6 desired columns, in the same order.</p>
<p>Note that these two datasets are non-overlapping in terms of the city-years (the latest estimates in the <strong>Ancient</strong> data are from 1000 AD, whereas the <strong>Modern</strong> data is all 2000 AD). This means we can combine them using <code>rbind()</code> AS LONG AS the two datasets have the exact same column names, same column data types, and same column order.</p>
<p>3c. Create a new dataframe (and give it a name) that uses <code>rbind()</code> to combine the two dataframes you created above. <strong>Then, filter out any rows with NA for the population estimate.</strong> How many rows with population values does your combined dataset have?</p>
</section>
<section id="part-4" class="level2">
<h2 class="anchored" data-anchor-id="part-4">Part 4</h2>
<p>Now, we will use the dataset you created above to practice some visualization.</p>
<p>4a. First, let’s make a line graph showing how city size changed over time for 4 cities of interest. Your graph should show city population size (in millions) on the y-axis vs.&nbsp;numerical year on the x-axis for these 4 cities: <strong>Luoyang, Istanbul, Alexandria, and Rome</strong>.</p>
<ul>
<li><p>Show the datapoints using <code>geom_point()</code>.</p></li>
<li><p>Use <code>geom_line()</code> to make a separate line connecting datapoints from the same city.</p></li>
<li><p>Colour the data/lines from the 4 cities differently. Include a legend for the city names.</p></li>
<li><p>Adjust the aesthetics/features/labels of your graph so that an audience would be able to understand it.</p></li>
</ul>
<p>4b. Re-make the graph above, but filter to show ONLY years BEFORE 1000 AD <span style="color: red"><strong>(i.e., &lt; 1000)</strong></span>. Remove the <code>geom_line()</code> from these graphs. Add on <code>geom_smooth()</code> with method = “loess” (make sure there is a separate geom_smooth line for each city).</p>
<p>4c. Re-make the graph above, but now use method = “lm” in <code>geom_smooth()</code>.</p>
<p>4d. What is <code>geom_smooth()</code> doing? Which method, “loess” or “lm”, is more appropriate for this particular graph?</p>
<p>4e. What do you notice is missing for Istanbul’s loess smooth? Can you determine why this feature is missing?</p>
<p>4f. Now, reproduce the graph with <code>geom_smooth()</code> using “loess” and with <span style="color: red"><strong>ALL years</strong></span> included. What do you notice about the <code>geom_smooth()</code> now that the most recent years are <strong>also</strong> included? Does it still make sense to apply the loess smoother as part of this particular visualization?</p>
<p>4g. Let’s make a different graph. Suppose we want to examine the correlation between city size estimates for two close years, 2300 BC and 2400 BC. We want to make a scatterplot with:</p>
<ul>
<li><strong>log10</strong> pop estimate in <strong>2400 BC</strong> on the y-axis, and</li>
<li><strong>log10</strong> pop estimate in <strong>2300 BC</strong> on the x-axis.</li>
</ul>
<p>Steps:</p>
<ol type="i">
<li><p>First, filter the data down to just those two years.</p></li>
<li><p>Next, reshape the data so that those two years are represented in wide format.</p></li>
<li><p>You may wish to rename the new columns to have a more appropriate name.</p></li>
<li><p>How many cities have a pop. estimate for BOTH 2400 BC and 2300 BC? Figure this out, and comment on it as your sample size; be sure to only count cities with non-NA values for both years.</p></li>
<li><p>Now, make your scatterplot of the log10 population in 2400 BC vs.&nbsp;the log10 population in 2300 BC. You may wish to use <code>scale_x_log10()</code> and <code>scale_y_log10()</code> to easily create a log-log plot while showing the axis tick numbers on the original scale (# of people).</p></li>
<li><p>Colour the datapoints by country and include a legend.</p></li>
<li><p>Include an <em>appropriate</em> amount of jitter in both x and y to make sure that the datapoints are visible (i.e., jitter so that we can see the datapoints that would otherwise be obscured by overplotting). But not so much jitter that it distorts our interpretation of the data!</p></li>
<li><p>Add a dashed line where y = x (i.e., a line with an intercept of 0 and slope of 1).</p></li>
<li><p>Add a solid red line showing the linear model (lm) of the relationship between y and x.</p></li>
</ol>
<p>4h. Finally, calculate the Pearson’s correlation coefficient, r, for the correlation shown in your graph above (i.e., for log10 pop in 2400 BC vs.&nbsp;log10 pop in 2300 BC). Do that outside of your pipes etc. The, remake your scatterplot above, and add text onto your graph that says ‘r = [value]’ (where you replace [value] with the correlation coef value that you have calculated above).</p>
</section>
<section id="part-5" class="level2">
<h2 class="anchored" data-anchor-id="part-5">Part 5</h2>
<p>For this question, we want to examine some summary stats by historical era.</p>
<p>5a. Take the combined dataset that you created in Part 3 above, and use mutate to add a new column to it, <code>era</code>, that gives the approximate historical era for the numerical <code>year</code> as follows:</p>
<ul>
<li>Bronze age is 3700 BC up to and including 1300 BC</li>
<li>Iron age is 1299 BC up to and including 600 BC</li>
<li>Classical age is 599 BC up to and including 500 AD</li>
<li>Middle ages is 501 AD up to and including 1500 AD</li>
<li>Modern age is 1501 AD until now</li>
</ul>
<p>Note: you can use <code>case_when()</code> within <code>mutate()</code> to do this in an elegant way that is less complicated for the user to read, OR use nested calls to <code>ifelse()</code> within <code>mutate()</code>.</p>
<p>5b. Now that you have created the <code>era</code> column, let’s get the overall average of log-tranformed city size for each year and era, using <code>group_by()</code> and <code>summarize()</code>. More specifically:</p>
<ol type="i">
<li><p>use <code>mutate()</code> to add a column with log-transformed city sizes,</p></li>
<li><p>then <code>group_by()</code> year and era,</p></li>
<li><p>then take the mean of the log-transformed city sizes for each year-era,</p></li>
<li><p>and assign this new dataset the name <strong>city_avg</strong>.</p></li>
</ol>
<p>5c. Now, plot a time series using <strong>city_avg</strong> that shows the global average log city size (y-axis) vs.&nbsp;year (x-axis) for Bronze - Middle ages (i.e., omit Modern from the graph).</p>
<ol type="i">
<li><p>Show the individual datapoints AND a thin black line connecting the points.</p></li>
<li><p>Color the datapoints by era and include a legend.</p></li>
<li><p>Be sure that the coloured points are layered on TOP of the thin black line (Hint: the order in which the ggplot + layers are built up will determine this).</p></li>
<li><p>Clean up any features/labels of the plot so an audience can understand it.</p></li>
<li><p>Which pre-modern eras showed the biggest jumps in average city size around the world?</p></li>
</ol>
<p><strong>OPTIONAL:</strong> Add semi-transparent rectangles in the background of the plot, one rectangle spanning the year range for each era, with the rectangles colour-coded to match the color scheme of the datapoints. The idea is to make it easier for the viewer to see the era transitions. Make the rectangles span the entire vertical/y-range of the plot. Hint: one way to do this is with <code>geom_rect()</code>. It’s helpful to first create a separate little dataframe with columns for <code>era</code>, <code>start_year</code>, and <code>end_year</code>. Then, add a <code>geom_rect()</code> layer that calls that dataframe.</p>
</section>
<section id="extra-optional-challenges" class="level2">
<h2 class="anchored" data-anchor-id="extra-optional-challenges">Extra optional challenges</h2>
<p>This is for extra (excellent) practice, and is not graded.</p>
<p>The <code>gapminder</code> dataset has info about the continent for different countries around the world:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>gapminder</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1,704 × 6
   country     continent  year lifeExp      pop gdpPercap
   &lt;fct&gt;       &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
 1 Afghanistan Asia       1952    28.8  8425333      779.
 2 Afghanistan Asia       1957    30.3  9240934      821.
 3 Afghanistan Asia       1962    32.0 10267083      853.
 4 Afghanistan Asia       1967    34.0 11537966      836.
 5 Afghanistan Asia       1972    36.1 13079460      740.
 6 Afghanistan Asia       1977    38.4 14880372      786.
 7 Afghanistan Asia       1982    39.9 12881816      978.
 8 Afghanistan Asia       1987    40.8 13867957      852.
 9 Afghanistan Asia       1992    41.7 16317921      649.
10 Afghanistan Asia       1997    41.8 22227415      635.
# ℹ 1,694 more rows</code></pre>
</div>
</div>
<p>Let’s use the continent info from <code>gapminder</code>, merging it into our other data on cities/pop sizes/eras that we created above. Our goal here will be to determine and plot the number (count) of major ancient cities for each continent-era. This will let us see where in the world the major ancient cities were, through the ages.</p>
<ol type="i">
<li><p>First, we will set up a dataframe with just the unique country and continent names from <code>gapminder</code>, as follows:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(cc <span class="ot">&lt;-</span> <span class="fu">unique</span>(gapminder[, <span class="fu">c</span>(<span class="st">'country'</span>, <span class="st">'continent'</span>)]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 142 × 2
   country     continent
   &lt;fct&gt;       &lt;fct&gt;    
 1 Afghanistan Asia     
 2 Albania     Europe   
 3 Algeria     Africa   
 4 Angola      Africa   
 5 Argentina   Americas 
 6 Australia   Oceania  
 7 Austria     Europe   
 8 Bahrain     Asia     
 9 Bangladesh  Asia     
10 Belgium     Europe   
# ℹ 132 more rows</code></pre>
</div>
</div>
<p>Next, do the following steps:</p></li>
<li><p>Using the city dataset where you have added an <strong>era</strong> column, filter to just <strong>pre-modern</strong> eras.</p></li>
<li><p>Merge the continent names from cc into your city dataset with <code>left_join()</code>, based on country names. Note: country names are provided both in the city dataset and cc, but they have different capitalization, so you will need to figure out how do the joining.</p></li>
<li><p>Filter to remove any rows where continent is <code>NA</code>.</p></li>
<li><p>Filter to include just one row per city-era that has the largest (max) population for that city and era. Hint: one way to do this is with <code>group_by()</code> and <code>summarize()</code>.</p></li>
<li><p>Then, determine how many ancient cities there were in each continent-era (i.e., count them). Hint: the output here should be a tibble with 15 rows…</p></li>
<li><p>Finally, use ggplot to make a grouped or stacked bar graph with <code>geom_bar()</code> showing these counts by continent and era. Put era on the x-axis. Reorder the x-axis era categories so that it’s chronological (Bronze, Iron, Classical, Middle). Use fill for continent.</p></li>
<li><p>Experiment with <code>position = 'stack'</code>, <code>position = 'dodge'</code>, and <code>position = 'fill'</code> for this. Which of these methods do you think is best for this particular graph? What do you conclude from this graph?</p></li>
</ol>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>